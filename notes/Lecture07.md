1. int *a[30][10] != int **a[10]
    应该等于int *(*)a[10] (括号加星表示指向数组的指针)

2. 注意! const int a = 10; a的类型不是int , 而是const int!!!
    而&a的类型为const int *而不是int *
```c 
const int x = 42;
int *pi = &x; // Dangerous: It discards the const qualifier.
const int *cpi = &x; // Better.
++*pi; // No error is generated by the compiler, but actually undefined behavior.
```

3. 你无法修改const T *类型指针指向的内容, 即使它并不是const类型变量!
```c 
int x = 42;
int *pi = &x;
const int *cpi = &x; // OK.
++*pi; // Correct, same as ++x.
++*cpi; // Error!
```

4. const类型的指针: Top level constness
    你无法将const类型的指针指向其他的地址!
    语法为PointeeType *const 
```c 
int x = 42;
int *const pc = &x;
++*pc; // OK.
int y = 30;
pc = &y; // Error.

// double-const: Also correct
const int *const cipc = &x;
```

5. 如果你需要打印一个地址, 请先将其显式强制转换为void *类型
```c 
printf("%p", (void *)ptr);
```

6. malloc(0) , calloc(0, N) and calloc(N, 0) 的行为是implementation-defined的, 它们可能返回空指针NULL, 如果它确实返回了一个非空地址, 那么你也必须free它, 否则会内存泄漏! 

7. malloc相较于array的优势: 定义一个过大的数组会直接导致栈溢出而程序崩溃, 但malloc一个过大的内存空间会返回空指针, 给程序补救的空间而不会直接崩溃

8. 任何标准库的函数在处理字符串时都会涉及到寻找'\0', 千万不要忘记在声明字符串时多留出一位来存储\0! 否则将导致UB !
```c 
char s[5] = "abcde"; // OK, but no place for '\0'.
printf("%s\n", s);
 // undefined behavior (missing '\0')
```

9. empty string只会包含一个'\0', 不存在一个物理意义上啥都没有的字符串!
```c 
char empty[] = ""; // `empty` is of type char[1], which contains only '\0'.
printf("%s\n", empty); // Prints only a newline.
printf(""); // Nothing is printed
```

10. scanf(%s)能接受字符串输入, 其中字符串中间一定没有空格, (若有空格会被当作两个字符串), 字符串左侧的空格会被忽略, 右侧的空格会被当作字符串结束的标志, 但scanf是不安全的， 因为scanf并不知道缓冲区的大小是多少

11. 使用fgets(char *str, size_t buffer_len, stdin)来接受一行字符串的输入
    puts(str)

12. strlen()的返回值并不包含最后的空字符'\0'!

13. strcpy()是不安全的, 因为它不知道dst字符串有多长, 可能造成缓冲区溢出, 如果两个内存区域overlap了, 它也不知道, 它只是机械的一个一个字符地从src复制到dst, 不对地址是否有效做任何检查
    strncpy()看似安全, 但它的行为更加诡异, 如果src的长度大于你给定的buffer size, 那么它不会复制'\0'!, 如果src的长度小于你给定的buffer size, 那么它会将buffer剩下的空间都设为0! 这会有严重的内存问题

14. strcmp()的返回值可能为-1 0 和1, 当str1 < str2返回-1, str1 == str2返回0

15. strlen()是很低效的, 因为他只是简单的遍历整个字符串, 因此下面程序的复杂度为O(n^2)
```c 
for (size_t i = 0; i < strlen(s); ++i) // very slow
// ...
```

16. 字符串字面量: 所有被双引号括起来的内容"abcde"
    字符串字面量会存储在只读内存区, 字符串字面量的类型为char [N+1], 
    你可以在C语言中将一个指针指向字符串字面量, 但这是极度危险的! 因为这块内存是只读的!

    一般在使用字符串字面量时, 请使用const关键字修饰!!! 避免对其的误操作(试图修改)
```c
char *p = "abcde"; // OK
p[3] = 'a'; // No compile-error, but undefined behavior,
// and possibly severe runtime-error.

const char *str = "abcde";
str[3] = 'a'; // compile-error

char arr[] = "abcde";
arr[3] = 'a'; // OK.
// `arr` contains a copy of "abcde".
```

17. 由字符串组成的数组: const char *stringarr[] = {"some", "str", "array"};
    实际上是char *[]类型的数组(由字符串指针组成的数组), 绝对不是二维数组!
    二维数组的长度一定不等于sizeof(T) * len 
    但字符串数组的长度一定是sizeof(char *) * len 


